[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "fastduck",
    "section": "",
    "text": "A bit of extra usability for duckdb… inspired by fastlite and sqlite_utils\nfastduck provides some development experience improvements for the standard duckdb python API.",
    "crumbs": [
      "fastduck"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "fastduck",
    "section": "Install",
    "text": "Install\npip install fastduck",
    "crumbs": [
      "fastduck"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "fastduck",
    "section": "How to use",
    "text": "How to use\nimport fastduck as fuck\n\nfrom fastduck import database\n\n\ndb = database('../data/chinook.duckdb')\ndb\n\nDuckDBPyConnection (chinook_main)\n\n\n\ndt = db.t\ndt\n\n(chinook_main) Tables: Album, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track, todos\n\n\nYou can use this to grab a single table…\n\nartist = dt.Artist\nartist\n\n\n\n\n\nArtistId\nName\n\n\n\n\n1\nAC/DC\n\n\n2\nAccept\n\n\n3\nAerosmith\n\n\n...\n...\n\n\n274\nNash Ensemble\n\n\n275\nPhilip Glass Ensemble\n\n\n\n275 rows x  2 cols      DuckDBPyRelation BASE_TABLE chinook.main.Artist \n\n\n\n\ncustomer = dt['Customer']\ncustomer\n\n\n\n\n\nCustomerId\nFirstName\nLastName\nCompany\nAddress\nCity\nState\nCountry\nPostalCode\nPhone\nFax\nEmail\nSupportRepId\n\n\n\n\n1\nLuís\nGonçalves\nEmbraer - Empresa Brasileira de Aeronáutica S.A.\nAv. Brigadeiro Faria Lima, 2170\nSão José dos Campos\nSP\nBrazil\n12227-000\n+55 (12) 3923-5555\n+55 (12) 3923-5566\nluisg@embraer.com.br\n3\n\n\n2\nLeonie\nKöhler\nNone\nTheodor-Heuss-Straße 34\nStuttgart\nNone\nGermany\n70174\n+49 0711 2842222\nNone\nleonekohler@surfeu.de\n5\n\n\n3\nFrançois\nTremblay\nNone\n1498 rue Bélanger\nMontréal\nQC\nCanada\nH2G 1A7\n+1 (514) 721-4711\nNone\nftremblay@gmail.com\n3\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n58\nManoj\nPareek\nNone\n12,Community Centre\nDelhi\nNone\nIndia\n110017\n+91 0124 39883988\nNone\nmanoj.pareek@rediff.com\n3\n\n\n59\nPuja\nSrivastava\nNone\n3,Raj Bhavan Road\nBangalore\nNone\nIndia\n560001\n+91 080 22289999\nNone\npuja_srivastava@yahoo.in\n3\n\n\n\n59 rows x  13 cols      DuckDBPyRelation BASE_TABLE chinook.main.Customer \n\n\n\n… or multiple tables at once:\n\ndt['Artist', 'Album', 'Genre']\n\n[DuckDBPyRelation BASE TABLE chinook.main.Artist \n ,\n DuckDBPyRelation BASE TABLE chinook.main.Album \n ,\n DuckDBPyRelation BASE TABLE chinook.main.Genre \n ]\n\n\nIt also provides auto-complete in Jupyter, IPython and nearly any other interactive Python environment:\n\n\n\nAutocomplete in Jupyter\n\n\nYou can check if a table is in the database already:\n\n'Artist' in dt\n\nTrue\n\n\nColumn work in a similar way to tables, using the c property:\n\nac = artist.c\nac, artist.columns\n\n(chinook.main.Artist Columns: ArtistId, Name, ['ArtistId', 'Name'])\n\n\nAuto-complete works for columns too:\n\n\n\nColumns autocomplete in Jupyter\n\n\nThe tables and views of a database got some interesting new attributes….\n\nartist.meta\n\n{'base': DuckDBPyConnection (chinook_main),\n 'catalog': 'chinook',\n 'schema': 'main',\n 'name': 'Artist',\n 'type': 'BASE TABLE',\n 'comment': None,\n 'shape': (275, 2)}\n\n\n\nartist.model\n\n[{'name': 'ArtistId',\n  'type': 'INTEGER',\n  'nullable': False,\n  'default': None,\n  'pk': True},\n {'name': 'Name',\n  'type': 'VARCHAR',\n  'nullable': True,\n  'default': None,\n  'pk': False}]\n\n\n\nartist.cls, type(artist.cls)\n\n(fastduck.core.Artist, type)\n\n\nduckdb replacement scans keep working and are wonderful for usage in SQL statements:\n\ndb.sql(\"select * from artist where artist.Name like 'AC/%'\")\n\n\n\n\n\nArtistId\nName\n\n\n\n\n1\nAC/DC\n\n\n\n1 rows x  2 cols      DuckDBPyRelation   \n\n\n\nYou can view the results of a query as records\n\ndb.sql(\"select * from artist where artist.Name like 'AC/%'\").to_recs()\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\nor as a list of lists\n\ndb.sql(\"select * from artist where artist.Name like 'AC/%'\").to_list()\n\n[[1, 'AC/DC']]\n\n\nAnd you there is also an alias for sql with to_recs simply called q\n\ndb.q(\"select * from artist where artist.Name like 'AC/%'\")\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\n\nDataclass support\nAs we briefly saw, a dataclass type with the names, types and defaults of the table is added to the Relation:\n\nabm = db.t.Album\nart = db.t.Artist\nacca_sql = f\"\"\"\nselect abm.* \nfrom abm join art using (ArtistID)\nwhere art.Name like 'AC/%'\n\"\"\"\nacca_dacca = db.q(acca_sql)\nacca_dacca\n\n[{'AlbumId': 1,\n  'Title': 'For Those About To Rock We Salute You',\n  'ArtistId': 1},\n {'AlbumId': 4, 'Title': 'Let There Be Rock', 'ArtistId': 1}]\n\n\n\nlet_b_rock_obj = abm.cls(**acca_dacca[-1])\nlet_b_rock_obj\n\nAlbum(AlbumId=4, Title='Let There Be Rock', ArtistId=1)\n\n\nYou can get the definition of the dataclass using fastcore’s dataclass_src – everything is treated as nullable, in order to handle auto-generated database values:\n\nfrom fastcore.xtras import hl_md, dataclass_src\n\nsrc = dataclass_src(db.t.Album.cls)\nhl_md(src, 'python')\n\n@dataclass\nclass Album:\n    AlbumId: int32 = None\n    Title: str = None\n    ArtistId: int32 = None",
    "crumbs": [
      "fastduck"
    ]
  },
  {
    "objectID": "00_core.html",
    "href": "00_core.html",
    "title": "Source",
    "section": "",
    "text": "::: {#cell-2 .cell 0=‘h’ 1=‘i’ 2=‘d’ 3=‘e’ 4=’ ’ 5=‘e’ 6=‘x’ 7=‘p’ 8=‘o’ 9=‘r’ 10=‘t’}\n:::\nWhen you import duckdb, there are two main concepts that you have to handle:\nA DuckDBPyConnection represents a connection to a DuckDB database in a file or memory\nDuckDB API has no concept of a Database, only of a connection that may envolve different attached databases (or catalogs) and schemas.\nA Catalog is just a holder for schemas, and schemas hold catalog entries, like tables, views, functions, types, etc..\nWe will change this behaviour in a bit…\nA DuckDBPyRelation represents a query. It is a table-like object that will be lazy executed and can be queried further.\nOnce it’s executed then yes, it contains the result set.\nBut when further projections are made on it, that result set is not used, the projections are just done on top of the original query as a subquery\nduckdb.table('tbl').sql(\"select a\")\nReally becomes, in essence: select a from (select * from tbl)\ndb = duckdb.connect()\ndb.sql(f\"FROM duckdb_tables()\")\n\n┌───────────────┬──────────────┬─────────────┬────────────┬───┬─────────────┬──────────────────────┬─────────┐\n│ database_name │ database_oid │ schema_name │ schema_oid │ … │ index_count │ check_constraint_c…  │   sql   │\n│    varchar    │    int64     │   varchar   │   int64    │   │    int64    │        int64         │ varchar │\n├───────────────┴──────────────┴─────────────┴────────────┴───┴─────────────┴──────────────────────┴─────────┤\n│                                                   0 rows                                                   │\n└────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\ntype(db.sql(f\"SELECT table_name FROM duckdb_tables()\"))\n\nduckdb.duckdb.DuckDBPyRelation\ndb.close()",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "00_core.html#improving-connection",
    "href": "00_core.html#improving-connection",
    "title": "Source",
    "section": "Improving Connection",
    "text": "Improving Connection\nWe want the developer to understand the connection as a database.\n\nimport duckdb\n\nconn = duckdb.connect()\nbecomes\n\nfrom fastduck import database\ndb = database()\nBy acessing the same Python API using fastduck, the developer shall get some niceties.\n::: {#cell-14 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n@wraps(duckdb.connect)\ndef database(*args, **kwargs):\n    db = duckdb.connect(*args, **kwargs)\n    return db\n:::\nLet’s start by simplifying the access to some information on the current catalog and schema in the connection.\n\ndb = database('../data/chinook.duckdb')\n\n::: {#cell-17 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef _current(self: DuckDBPyConnection): return self.sql('select current_catalog, current_schema').fetchone()\n@patch(as_prop=True)\ndef catalog(self: DuckDBPyConnection): return _current(self)[0]\n\n@patch(as_prop=True)\ndef schema(self: DuckDBPyConnection): return _current(self)[1]\n\n@patch(as_prop=True) # just the name part in the alias\ndef name(self:DuckDBPyRelation): return self.alias.split('.')[-1]\n\n@patch\ndef __getitem__(self:DuckDBPyRelation, idxs) -&gt; DuckDBPyRelation: # selecting by passing a list of column names\n    return self.select(*idxs) if isinstance(idxs, Union[List, Set, Tuple]) else self.select(idxs)\n@patch \ndef to_recs(self:DuckDBPyRelation) -&gt; List[Dict[str, Any]]:\n    '''The relation as a list of records'''\n    return self.df().to_dict(orient='records')\n@patch \ndef to_list(self:DuckDBPyRelation) -&gt; List[List]:\n    '''The relation as a list'''\n    return [list(r.values()) if len(r.values())&gt;1 else list(r.values())[0] for r in self.to_recs() ]\n@patch \ndef q(self:DuckDBPyConnection, *args, **kwargs) -&gt; List[Dict[str, Any]]:\n    '''Run a query and return the result as a list of records'''\n    return self.sql(*args, **kwargs).to_recs()\n\n:::\n\nalbum = db.sql(\"select * from Album\")\nalbum['AlbumId', 'Title'].limit(5)\n\n┌─────────┬───────────────────────────────────────┐\n│ AlbumId │                 Title                 │\n│  int32  │                varchar                │\n├─────────┼───────────────────────────────────────┤\n│       1 │ For Those About To Rock We Salute You │\n│       2 │ Balls to the Wall                     │\n│       3 │ Restless and Wild                     │\n│       4 │ Let There Be Rock                     │\n│       5 │ Big Ones                              │\n└─────────┴───────────────────────────────────────┘\n\n\n\ndb.table('Album')['AlbumId', 'Title'].limit(2).to_recs()\n\n[{'AlbumId': 1, 'Title': 'For Those About To Rock We Salute You'},\n {'AlbumId': 2, 'Title': 'Balls to the Wall'}]\n\n\nWe also need a way to know the tables in the database.\n::: {#cell-21 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n@patch(as_prop=True)\ndef tables(self: DuckDBPyConnection) -&gt; DuckDBPyRelation:\n    '''Returns the tables in the database'''\n    return self.sql(f\"\"\"\n        select distinct database_name as catalog, schema_name as schema, table_name as name,\n        'BASE TABLE' as type, comment from duckdb_tables() union all \n        select distinct database_name as catalog, schema_name as schema, view_name as name, \n        'VIEW' as type, comment from duckdb_views() where internal=False order by catalog, type, name\"\"\")\n    \n@patch(as_prop=True)\ndef views(self: DuckDBPyConnection) -&gt; DuckDBPyRelation:\n    '''Returns the views in current schema'''\n    return self.tables.filter(f\"type =='VIEW' and catalog='{self.catalog}' and schema = '{self.schema}'\")\n@patch(as_prop=True)\ndef base_tables(self: DuckDBPyConnection) -&gt; DuckDBPyRelation:\n    '''Returns the base tables in current schema'''\n    return self.tables.filter(f\"type =='BASE TABLE' and catalog='{self.catalog}' and schema = '{self.schema}'\")\n\n@patch(as_prop=True)\ndef schemas(self: DuckDBPyConnection) -&gt; DuckDBPyRelation:\n    '''Returns the schemas in the database'''\n    return self.tables.project(f\"catalog || '_' || schema as catalog_schema\").distinct()\n:::\n\ndb.schemas\n\n┌────────────────┐\n│ catalog_schema │\n│    varchar     │\n├────────────────┤\n│ chinook_main   │\n└────────────────┘\n\n\n\ndb.views.limit(3)\n\n┌─────────┬─────────┬───────────┬─────────┬─────────────┐\n│ catalog │ schema  │   name    │  type   │   comment   │\n│ varchar │ varchar │  varchar  │ varchar │   varchar   │\n├─────────┼─────────┼───────────┼─────────┼─────────────┤\n│ chinook │ main    │ a_view    │ VIEW    │ Just a view │\n│ chinook │ main    │ temp_view │ VIEW    │ NULL        │\n└─────────┴─────────┴───────────┴─────────┴─────────────┘\n\n\nThe functions bellow add some utilities that are useful for working with tables and views in a database.\n::: {#cell-25 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n@patch\ndef datamodel(self: DuckDBPyConnection, table_name:str) -&gt;List[Dict]:\n    ''' Returns the data model of a table or view. \n    The columns names, types, nullable status, default value and\n    primary key status.'''\n    \n    return [{'name': r[1], 'type': r[2], 'nullable': not r[3], 'default': r[4], 'pk': r[5]} \n            for r in self.sql(f\"PRAGMA table_info='{table_name}'\").fetchall()]\n:::\n\ndb.datamodel('Artist')\n\n[{'name': 'ArtistId',\n  'type': 'INTEGER',\n  'nullable': False,\n  'default': None,\n  'pk': True},\n {'name': 'Name',\n  'type': 'VARCHAR',\n  'nullable': True,\n  'default': None,\n  'pk': False}]\n\n\n::: {#cell-27 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef convertTypes(s:str)-&gt;type:\n    ''' Convert DuckDB types to Python and Numpy types'''\n    d = {\n        # Built-in types\n        'BOOLEAN': bool,\n        'BLOB': bytearray,  # For bytes, bytearray can be used in Python\n        'DOUBLE': float,\n        'BIGINT': int,\n        'VARCHAR': str,\n        'VARCHAR[]': str,\n    \n        # NumPy DTypes\n        'FLOAT': np.float32,\n        'DOUBLE': float,\n        'SMALLINT': np.int16,\n        'INTEGER': np.int32,\n        'TINYINT': np.int8,\n        'USMALLINT': np.uint16,\n        'UINTEGER': np.uint32,\n        'UBIGINT': np.uint64,\n        'UTINYINT': np.uint8,\n        'TIMESTAMP': np.timedelta64\n    }\n    if s in d: return d[s]\n    if s[:7]=='DECIMAL': return float\n    raise ValueError(f'Unknown type {s}')\n\n\nimport re, keyword\ndef clean(s):\n    s = re.sub(r'\\W|^(?=\\d)', '_', s)\n    return s + '_' if keyword.iskeyword(s) else s\n\n@patch\ndef dataclass(self: DuckDBPyConnection, \n              table_name:str, # table or view name\n              pref='', # prefix to add to the field names\n              suf='', # suffix to add to the field names\n              cls_name:str = None # defaults to table_name\n              ) -&gt; type:\n    '''Creates a `dataclass` type from a table or view in the database.'''\n    cls_name = cls_name or table_name\n    fields = self.datamodel(table_name)\n    fields = [(clean(pref+f['name']+suf), convertTypes(f['type']) if not f['nullable'] else convertTypes(f['type'])|None , field(default=f['default'])) for f in fields]\n    return make_dataclass(table_name, fields)\n:::\n\nartist_dc = db.dataclass('Artist')\nsrc = dataclass_src(artist_dc)\nhl_md(src, 'python') # fix error in nbdev_prepare\n\n@dataclass\nclass Artist:\n    ArtistId: int32 = None\n    Name: str | None = None\n\n\n\nacdc = db.sql(f\"select * from artist where artist.Name like 'AC/%'\").df().to_dict(orient='records')\nacdc\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\n\nacdc_object = artist_dc(**acdc[0])\nacdc_object\n\nArtist(ArtistId=1, Name='AC/DC')",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "00_core.html#relation-utilities",
    "href": "00_core.html#relation-utilities",
    "title": "Source",
    "section": "Relation utilities",
    "text": "Relation utilities\nOnce we know that a certain DuckDBPyRelation is a table (or view), we can also make it keep some valuable props.\n::: {#cell-33 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n_saved = {}\n\ndef _set_attr(obj, k, v): #hash to avoid collisions\n    _saved[str(hash(obj)) + '_' + k] = v\n\ndef _get_attr(obj, key):\n    k = str(hash(obj)) + '_' + key\n    return _saved[k] if k in _saved else None\n\n@patch\ndef _set(self: DuckDBPyRelation, k, v):\n    _set_attr(self, k, v)\n\n@patch\ndef _get(self: DuckDBPyRelation, key):\n    return _get_attr(self, key)\n\n@patch\ndef _set(self: DuckDBPyConnection, k, v):\n    _set_attr(self, k, v)\n\n@patch\ndef _get(self: DuckDBPyConnection, key):\n    return _get_attr(self, key)\n\n\ndef custom_dir(c, add): return sorted(dir(type(c)) + list(c.__dict__.keys()) if hasattr(c, '__dict__') else [] + add)\n\ndef create_patch_property(name):\n    @patch(as_prop=True)\n    def prop(self: DuckDBPyRelation):\n        return self._get(name)\n    return prop\n\nprops = ['cls', 'rel', 'model', 'meta']\nfor p in props: setattr(DuckDBPyRelation, p, create_patch_property(p))\n\n@patch\ndef __dir__(self:DuckDBPyRelation) -&gt; List[str]: return custom_dir(DuckDBPyRelation, props)\n    \ndef create_prop(c, name, f): setattr(c, name, property(f))\n@patch(as_prop=True)\ndef cls(self:DuckDBPyRelation): return self._get('cls')\n\n@patch(as_prop=True)\ndef model(self:DuckDBPyRelation): return self._get('model')\n\n@patch(as_prop=True)\ndef meta(self:DuckDBPyRelation): return self._get('meta')\n\n@patch(as_prop=True)\ndef rel(self:DuckDBPyRelation): return self._get('rel')\n\n\n@patch\ndef table(self:DuckDBPyConnection, name:str, schema:str= None, catalog:str=None) -&gt; DuckDBPyRelation:\n    if isinstance(name, Union[List, Set, Tuple]): return [self.table(n) for n in name]\n    if not isinstance(name,str): raise AttributeError\n    r = self.tables.filter(f\"name == '{name}' and schema == '{schema or self.schema}' and catalog =='{catalog or self.catalog}'\")\n    catalog, schema, name, type, comment = r.fetchone()\n    tbl = self.sql(f\"from {catalog}.{schema}.{name}\")\n    tbl = tbl.set_alias(f\"{catalog}.{schema}.{name}\")\n    tbl._set('cls', self.dataclass(name))\n    tbl._set('model', self.datamodel(name))\n    meta = {'base': self, 'catalog': catalog, 'schema': schema, 'name': name, 'type': type, 'comment': comment, 'shape': tbl.shape}\n    tbl._set('meta', meta)\n    tbl._set('rel', tbl)\n    return tbl\n\n:::\n::: {#cell-34 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n@patch\ndef _select(self:DuckDBPyRelation, k) -&gt; DuckDBPyRelation:\n    return self.select(k) if isinstance(k, str) else self.select(*k)\n\n@patch(as_prop=True)\ndef c(self:DuckDBPyRelation): \n    '''Column autocomplete'''\n    return _Getter(self, 'column', self.columns, self._select)\n:::\n\ndb\n\n&lt;duckdb.duckdb.DuckDBPyConnection&gt;\n\n\n\nAutocomplete\nWe want an easy access to table information.\nlike db.tables should work similar to the .table cli command.\n::: {#cell-37 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef noop(*args, **kwargs): return None\ndef identity(x): return x\n\n\nclass _Getter: \n    \"\"\" A Getter utility check https://github.com/AnswerDotAI/fastlite \"\"\"\n    def __init__(self, db:DuckDBPyConnection, type:str='', dir:List=[], get=noop): store_attr()    \n    def __dir__(self): return self.dir\n    def __str__(self): return \", \".join(dir(self))\n    def __repr__(self): return f\"{str(self.db).split(' ')[-1]} {self.type.title()}s: {str(self)}\"\n    def __contains__(self, s:str): return s in dir(self)\n    def __getitem__(self, k): return self.get(k)\n    def __getattr__(self, k):\n        if k[0]!='_': return self.get(k)\n        else: raise AttributeError \n\n@patch\ndef use(self:DuckDBPyConnection, catalog_schema:str=None, catalog:str=None, schema=None) -&gt; None:\n    if not catalog_schema and not catalog and not schema: return self\n    catalog, schema = catalog_schema.split('_') if catalog_schema else (catalog, schema)\n    catalog = catalog or self.catalog\n    schema = schema or self.schema\n    self.sql(f\"use {catalog}.{schema}\")\n\n@patch\ndef get_schema(self: DuckDBPyConnection, catalog_schema: str):\n    self.use(catalog_schema)\n    self._set(catalog_schema, self)\n    return self\n\n@patch(as_prop=True) # tables\ndef s(self:DuckDBPyConnection): \n    '''Autocomplete functonality for schemas'''\n    return _Getter(self, 'schema', self.tables.project(f\"catalog || '_' || schema\").distinct().to_list(), self.get_schema)\n@patch(as_prop=True) # tables\ndef t(self:DuckDBPyConnection): \n    '''Autocomplete functonality for tables'''\n    return _Getter(self,'table', self.base_tables.select('name').to_list(), self.table)\n@patch(as_prop=True) # views\ndef v(self:DuckDBPyConnection): \n    '''Autocomplete functonality for views'''\n    return _Getter(self, 'view', self.views.select('name').to_list(), self.table)\n@patch(as_prop=True) # functions\ndef fns(self:DuckDBPyConnection): raise NotImplementedError\n# def fns(self:DuckDBPyConnection): return _Getter(self, f\"SELECT function_name FROM duckdb_functions() WHERE schema_name = '{self.schema}' and internal = False\")\n\n@patch(as_prop=True) # secrets\ndef shh(self:DuckDBPyConnection): raise NotImplementedError\n# def shh(self:DuckDBPyConnection): return _Getter(self, f\"SELECT name FROM duckdb_secrets()\")\n\n@patch\ndef __repr__(self:DuckDBPyConnection): return f'{self.__class__.__name__} ({self.catalog}_{self.schema})'\n:::\n:::\n\n\n\nAutocomplete in Jupyter\n\n\n:::\n\n\na = db.t.Album.c['AlbumId', 'Title'].limit(4)\na\n\n┌─────────┬───────────────────────────────────────┐\n│ AlbumId │                 Title                 │\n│  int32  │                varchar                │\n├─────────┼───────────────────────────────────────┤\n│       1 │ For Those About To Rock We Salute You │\n│       2 │ Balls to the Wall                     │\n│       3 │ Restless and Wild                     │\n│       4 │ Let There Be Rock                     │\n└─────────┴───────────────────────────────────────┘\n\n\nLet’s also improve the representation of Relations.\n\ndb.s.chinook_main.t.Album\n\n┌─────────┬─────────────────────────────────────────────────────────────────────┬──────────┐\n│ AlbumId │                                Title                                │ ArtistId │\n│  int32  │                               varchar                               │  int32   │\n├─────────┼─────────────────────────────────────────────────────────────────────┼──────────┤\n│       1 │ For Those About To Rock We Salute You                               │        1 │\n│       2 │ Balls to the Wall                                                   │        2 │\n│       3 │ Restless and Wild                                                   │        2 │\n│       4 │ Let There Be Rock                                                   │        1 │\n│       5 │ Big Ones                                                            │        3 │\n│       6 │ Jagged Little Pill                                                  │        4 │\n│       7 │ Facelift                                                            │        5 │\n│       8 │ Warner 25 Anos                                                      │        6 │\n│       9 │ Plays Metallica By Four Cellos                                      │        7 │\n│      10 │ Audioslave                                                          │        8 │\n│       · │     ·                                                               │        · │\n│       · │     ·                                                               │        · │\n│       · │     ·                                                               │        · │\n│     338 │ Nielsen: The Six Symphonies                                         │      267 │\n│     339 │ Great Recordings of the Century: Paganini's 24 Caprices             │      268 │\n│     340 │ Liszt - 12 Études D'Execution Transcendante                         │      269 │\n│     341 │ Great Recordings of the Century - Shubert: Schwanengesang, 4 Lieder │      270 │\n│     342 │ Locatelli: Concertos for Violin, Strings and Continuo, Vol. 3       │      271 │\n│     343 │ Respighi:Pines of Rome                                              │      226 │\n│     344 │ Schubert: The Late String Quartets & String Quintet (3 CD's)        │      272 │\n│     345 │ Monteverdi: L'Orfeo                                                 │      273 │\n│     346 │ Mozart: Chamber Music                                               │      274 │\n│     347 │ Koyaanisqatsi (Soundtrack from the Motion Picture)                  │      275 │\n├─────────┴─────────────────────────────────────────────────────────────────────┴──────────┤\n│ 347 rows (20 shown)                                                            3 columns │\n└──────────────────────────────────────────────────────────────────────────────────────────┘\n\n\n\nDuckDBPyRelation._repr_markdown_??\n\nObject `DuckDBPyRelation._repr_markdown_` not found.\n\n\n\nprint(a.df().to_markdown(index=False))\n\n|   AlbumId | Title                                 |\n|----------:|:--------------------------------------|\n|         1 | For Those About To Rock We Salute You |\n|         2 | Balls to the Wall                     |\n|         3 | Restless and Wild                     |\n|         4 | Let There Be Rock                     |\n\n\n::: {#cell-44 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n@patch\ndef __str__(self:DuckDBPyRelation): return f'{self.alias}'\n\n@patch\ndef __repr__(self:DuckDBPyRelation): \n    return f\"{self.__class__.__name__} {self.meta['type'] if self.meta else ''} {self.alias if self.alias[:7]!='unnamed' else ''} \\n\\n\"\n@patch\ndef _repr_markdown_(self: DuckDBPyRelation): \n    markdown =  f\"#### {self.__repr__()} \"\n    if self.meta and self.meta['comment']: markdown += f\"&gt; {self.meta['comment']}\\n\\n\"\n    df = self.df()\n    if self.shape[0] &gt; 5: \n        head = df.head(3)\n        tail = df.tail(2)\n        ellipsis = pd.DataFrame([[\"...\"] * df.shape[1]], columns=df.columns)\n        df = pd.concat([head, ellipsis, tail])\n    markdown += df.to_markdown(index=False, tablefmt=\"pipe\")\n    markdown += f\"\\n\\n {self.shape[0]} rows  x  {self.shape[1]} cols \"\n    return markdown\n\n@patch\ndef _repr_html_(self: DuckDBPyRelation):\n   \n    df = self.df()\n    if self.shape[0] &gt; 5: \n        head = df.head(3)\n        tail = df.tail(2)\n        ellipsis = pd.DataFrame([[\"...\"] * df.shape[1]], columns=df.columns)\n        df = pd.concat([head, ellipsis, tail])\n    h = df.to_html(index=False)\n    h += f\"&lt;p&gt;{self.shape[0]} rows x  {self.shape[1]} cols &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{self.__class__.__name__} {self.meta['type'].replace(' ', '_') if self.meta else ''} {self.alias if self.alias[:7]!='unnamed' else ''} &lt;/p&gt;\"\n    h += f\"&lt;p&gt;&lt;i&gt;{self.meta['comment']}&lt;/i&gt;&lt;/p&gt;\\n\\n\" if self.meta and self.meta['comment'] else ''\n    return h\n\n\n:::\n\ndb.tables.show()\n\n┌─────────┬─────────┬───────────────┬────────────┬─────────────┐\n│ catalog │ schema  │     name      │    type    │   comment   │\n│ varchar │ varchar │    varchar    │  varchar   │   varchar   │\n├─────────┼─────────┼───────────────┼────────────┼─────────────┤\n│ chinook │ main    │ Album         │ BASE TABLE │ Album table │\n│ chinook │ main    │ Artist        │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Customer      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Employee      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Genre         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Invoice       │ BASE TABLE │ NULL        │\n│ chinook │ main    │ InvoiceLine   │ BASE TABLE │ NULL        │\n│ chinook │ main    │ MediaType     │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Playlist      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ PlaylistTrack │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Track         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ todos         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ a_view        │ VIEW       │ Just a view │\n│ chinook │ main    │ temp_view     │ VIEW       │ NULL        │\n├─────────┴─────────┴───────────────┴────────────┴─────────────┤\n│ 14 rows                                            5 columns │\n└──────────────────────────────────────────────────────────────┘\n\n\n\n\ndb.v.a_view\n\n\n\n\n\nTrackId\nName\nAlbumId\nMediaTypeId\nGenreId\nComposer\nMilliseconds\nBytes\nUnitPrice\n\n\n\n\n1\nFor Those About To Rock (We Salute You)\n1\n1\n1\nAngus Young, Malcolm Young, Brian Johnson\n343719\n11170334\n0.98\n\n\n2\nBalls to the Wall\n2\n2\n1\nNone\n342562\n5510424\n0.98\n\n\n3\nFast As a Shark\n3\n2\n1\nF. Baltes, S. Kaufman, U. Dirkscneider & W. Hoffman\n230619\n3990994\n0.98\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3502\nQuintet for Horn, Violin, 2 Violas, and Cello in E Flat Major, K. 407/386c: III. Allegro\n346\n2\n24\nWolfgang Amadeus Mozart\n221331\n3665114\n0.98\n\n\n3503\nKoyaanisqatsi\n347\n2\n10\nPhilip Glass\n206005\n3305164\n0.98\n\n\n\n3503 rows x  9 cols      DuckDBPyRelation VIEW chinook.main.a_view Just a view\n\n\n\n\n\ndb.sql('select * from Album')\n\n\n\n\n\nAlbumId\nTitle\nArtistId\n\n\n\n\n1\nFor Those About To Rock We Salute You\n1\n\n\n2\nBalls to the Wall\n2\n\n\n3\nRestless and Wild\n2\n\n\n...\n...\n...\n\n\n346\nMozart: Chamber Music\n274\n\n\n347\nKoyaanisqatsi (Soundtrack from the Motion Picture)\n275\n\n\n\n347 rows x  3 cols      DuckDBPyRelation   \n\n\n\n\ndb.t.Genre\n\n\n\n\n\nGenreId\nName\n\n\n\n\n1\nRock\n\n\n2\nJazz\n\n\n3\nMetal\n\n\n...\n...\n\n\n24\nClassical\n\n\n25\nOpera\n\n\n\n25 rows x  2 cols      DuckDBPyRelation BASE_TABLE chinook.main.Genre \n\n\n\n\na\n\n\n\n\n\nAlbumId\nTitle\n\n\n\n\n1\nFor Those About To Rock We Salute You\n\n\n2\nBalls to the Wall\n\n\n3\nRestless and Wild\n\n\n4\nLet There Be Rock\n\n\n\n4 rows x  2 cols      DuckDBPyRelation  chinook.main.Album \n\n\n\n\nReplacement Scans\nYou may be asking yourself why I am patching DuckDBPyRelation and DuckDBPyConnection instead of subclassing them. The problem is that these classes do not allow subclassing. They do not implement __init__.\nWe could have create our own classes like Database and Table and just wrap DuckDBPy objects. But then we would loose a very nice feature of the PyRelation objects…..\nreplacement scans.\n\na = db.t.Album\n\n\ndb.sql(\"select * from a\")\n\n\n\n\n\nAlbumId\nTitle\nArtistId\n\n\n\n\n1\nFor Those About To Rock We Salute You\n1\n\n\n2\nBalls to the Wall\n2\n\n\n3\nRestless and Wild\n2\n\n\n...\n...\n...\n\n\n346\nMozart: Chamber Music\n274\n\n\n347\nKoyaanisqatsi (Soundtrack from the Motion Picture)\n275\n\n\n\n347 rows x  3 cols      DuckDBPyRelation   \n\n\n\nI did not had to use a f-string and pass the variable. DuckDBPy objects (as well as Pandas and Polars Dataframes, Arrow tables, and Datasets) are replaced in the query automagically.\n\ndb.sql(f\"select * from {a}\")\n\n\n\n\n\nAlbumId\nTitle\nArtistId\n\n\n\n\n1\nFor Those About To Rock We Salute You\n1\n\n\n2\nBalls to the Wall\n2\n\n\n3\nRestless and Wild\n2\n\n\n...\n...\n...\n\n\n346\nMozart: Chamber Music\n274\n\n\n347\nKoyaanisqatsi (Soundtrack from the Motion Picture)\n275\n\n\n\n347 rows x  3 cols      DuckDBPyRelation   \n\n\n\n\nstr(a)\n\n'chinook.main.Album'\n\n\n\ndb.tables\n\n\n\n\n\ncatalog\nschema\nname\ntype\ncomment\n\n\n\n\nchinook\nmain\nAlbum\nBASE TABLE\nAlbum table\n\n\nchinook\nmain\nArtist\nBASE TABLE\nNone\n\n\nchinook\nmain\nCustomer\nBASE TABLE\nNone\n\n\n...\n...\n...\n...\n...\n\n\nchinook\nmain\na_view\nVIEW\nJust a view\n\n\nchinook\nmain\ntemp_view\nVIEW\nNone\n\n\n\n14 rows x  5 cols      DuckDBPyRelation",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "00_core.html#database-management",
    "href": "00_core.html#database-management",
    "title": "Source",
    "section": "Database management",
    "text": "Database management\n\nAttach, Detach and Use\n::: {#cell-60 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\nclass RemoteSqliteError(Exception): pass\nclass InvalidPathError(Exception): pass\n\n@patch\ndef attach(self: DuckDBPyConnection, path, read_only:bool = False, type:Literal['duckdb' | 'sqlite']='duckdb', catalog_name:str=None) -&gt; None:\n    type = 'sqlite' if Path(path).suffix =='.sqlite' else type\n    if path.startswith(('s3://', 'gcp://', 'https://')):\n        self.install_extension('httpfs')\n        self.load_extension('httpfs')\n        read_only = True\n        if type =='sqlite': raise RemoteSqliteError('Cannot attach to a remote sqlite database.')\n    elif not Path(path).exists(): raise InvalidPathError(f\"Couldn't find {path}\")\n    self.install_extension('sqlite')\n    self.load_extension('sqlite')\n    o = \"(TYPE sqlite, \" if type=='sqlite' else \"(\"\n    o += f\"READ_ONLY  {read_only})\"\n    q = f\"'{path}' {'AS ' + catalog_name if catalog_name else ''} {o}\"\n    self.sql(f\"ATTACH {q}\")\n:::\n\n@patch\ndef detach(self: DuckDBPyConnection, catalog_name) -&gt; None:\n    if catalog_name in self.schemas.to_list(): self.sql(f\"DETACH {catalog_name.split('_')[0]}\")\n\n\ndb.attach('../data/chinook.sqlite', catalog_name='lite')\n\n\ndb.schemas\n\n\n\n\n\ncatalog_schema\n\n\n\n\nchinook_main\n\n\nlite_main\n\n\n\n2 rows x  1 cols      DuckDBPyRelation   \n\n\n\n\ndb.detach('lite_main')\n\n\n\nDrop\n::: {#cell-66 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\ndef find_matches(pattern: str, items: List[str]) -&gt; List[str]:\n    regex_pattern = re.compile(pattern)\n    return [item for item in items if regex_pattern.match(item)]\n    \n@patch\ndef __contains__(self:DuckDBPyConnection, name:str):\n    schm, _, tbl = name.rpartition('.')\n    return tbl in self.tables.filter(f\"schema = '{schm or self.schema}'\").select('name').to_list()\n\n@patch\ndef drop(self: DuckDBPyConnection, pattern: str):\n    '''Drop a table or view'''\n    schm, _, tbl = pattern.rpartition('.')\n    schm = schm or self.schema\n    dropping = find_matches('.'.join([schm, tbl]), [rec['schema']+'.'+rec['name'] for rec in db.tables.filter(f\"catalog = '{db.catalog}'\").to_recs()])\n    for tbl in dropping: self.sql(f\"DROP TABLE {tbl}\")\n:::\n\ndb.tables.show()\n\n┌─────────┬─────────┬───────────────┬────────────┬─────────────┐\n│ catalog │ schema  │     name      │    type    │   comment   │\n│ varchar │ varchar │    varchar    │  varchar   │   varchar   │\n├─────────┼─────────┼───────────────┼────────────┼─────────────┤\n│ chinook │ main    │ Album         │ BASE TABLE │ Album table │\n│ chinook │ main    │ Artist        │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Customer      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Employee      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Genre         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Invoice       │ BASE TABLE │ NULL        │\n│ chinook │ main    │ InvoiceLine   │ BASE TABLE │ NULL        │\n│ chinook │ main    │ MediaType     │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Playlist      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ PlaylistTrack │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Track         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ todos         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ a_view        │ VIEW       │ Just a view │\n│ chinook │ main    │ temp_view     │ VIEW       │ NULL        │\n├─────────┴─────────┴───────────────┴────────────┴─────────────┤\n│ 14 rows                                            5 columns │\n└──────────────────────────────────────────────────────────────┘\n\n\n\n\ndb.drop('non_existent')\n\n\n\nCreate Table or View\n::: {#cell-70 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n@patch\ndef _create(self: DuckDBPyConnection, type: str, fileglob: str, table_name: Optional[str] = None, \n            filetype: Optional[Literal['csv', 'xlsx', 'json', 'parquet', 'sqlite']] = None, \n            replace: bool = False, as_name: Optional[str] = None, *args, **kwargs):\n    filepath, name = Path(fileglob), as_name or table_name or Path(fileglob).stem\n    if name in self and not replace: raise ValueError(f\"Table {name} already exists\")\n    self.drop(name)\n    filetype = filetype or filepath.suffix[1:]\n    options = ', '.join(f\"{k}={repr(v)}\" for k, v in kwargs.items())\n    \n    if filetype == 'sqlite':\n        self.install_extension('sqlite'), self.load_extension('sqlite')\n        self.sql(f\"CREATE {type} {name} AS SELECT * FROM sqlite_scan('{filepath}', {table_name} {options})\")\n    elif filetype == 'xlsx':\n        self.install_extension('spatial'), self.load_extension('spatial')\n        self.sql(f\"CREATE {type} {name} AS SELECT * FROM st_read('{filepath}' {options})\")\n    else:\n        getattr(self, f'read_{filetype}')(fileglob, *args, **kwargs).to_table(name)\n\n@patch\ndef create_table(self: DuckDBPyConnection, \n                 fileglob: str, # file path or glob\n                 table_name: Optional[str] = None, # table name\n                 filetype: Optional[Literal['csv', 'xlsx', 'json', 'parquet', 'sqlite']] = None, # file type\n                 as_name:Optional[str]=None ,\n                 replace: bool = False, # replace existing table\n                 *args, **kwargs \n                 ):\n    '''Create a table from a file'''\n    return self._create('TABLE', fileglob, table_name, filetype, replace, as_name, *args, **kwargs)\n\n@patch\ndef create_view(self: DuckDBPyConnection, \n                 fileglob: str, # file path or glob\n                 view_name: Optional[str] = None, # view name\n                 filetype: Optional[Literal['csv', 'xlsx', 'json', 'parquet', 'sqlite']] = None, # file type\n                 replace: bool = False,  # replace existing view\n                 as_name:Optional[str]=None ,\n                 *args, **kwargs\n                 ):\n    '''Create a view from a file'''\n    return self._create('VIEW', fileglob, view_name, filetype, replace, as_name, *args, **kwargs)\n    \n:::\n\ndb.create_table('../data/username.latin1.csv', 'latin', replace=True)\ndb.tables\n\n\n\n\n\ncatalog\nschema\nname\ntype\ncomment\n\n\n\n\nchinook\nmain\nAlbum\nBASE TABLE\nAlbum table\n\n\nchinook\nmain\nArtist\nBASE TABLE\nNone\n\n\nchinook\nmain\nCustomer\nBASE TABLE\nNone\n\n\n...\n...\n...\n...\n...\n\n\nchinook\nmain\na_view\nVIEW\nJust a view\n\n\nchinook\nmain\ntemp_view\nVIEW\nNone\n\n\n\n15 rows x  5 cols      DuckDBPyRelation   \n\n\n\n\ndb.create_view('../data/username.latin1.csv', 'latin1view', replace=True)\n\n\ndb.tables.filter(f\"name like '%latin%'\")\n#  db.sql(\"select distinct database_name, schema_name, table_name, column_name from duckdb_columns()\")\n# db.sql(\"attach database '../data/chinook.sqlite' as sqlite\")\n\n\n\n\n\ncatalog\nschema\nname\ntype\ncomment\n\n\n\n\nchinook\nmain\nlatin\nBASE TABLE\nNone\n\n\nchinook\nmain\nlatin1view\nBASE TABLE\nNone\n\n\n\n2 rows x  5 cols      DuckDBPyRelation   \n\n\n\n\ndb.drop('latin1view')\ndb.drop('latin')\n\n\n# from fastcore.test import test_fail\n# test_fail(db.drop, 'banana') # fix error in nbdev_prepare\n\n\ndb.create_table('https://jsonplaceholder.typicode.com/todos/', 'todos', filetype='json', replace=True)\n\n\ndb.t.todos.limit(10)\n\n\n\n\n\nuserId\nid\ntitle\ncompleted\n\n\n\n\n1\n1\ndelectus aut autem\nFalse\n\n\n1\n2\nquis ut nam facilis et officia qui\nFalse\n\n\n1\n3\nfugiat veniam minus\nFalse\n\n\n...\n...\n...\n...\n\n\n1\n9\nmolestiae perspiciatis ipsa\nFalse\n\n\n1\n10\nillo est ratione doloremque quia maiores aut\nTrue\n\n\n\n10 rows x  4 cols      DuckDBPyRelation  chinook.main.todos \n\n\n\n\n# db.create_table('https://huggingface.co/datasets/ibm/duorc/resolve/refs%2Fconvert%2Fparquet/ParaphraseRC/test/0000.parquet', 'hf_movies')\n\n\n# db.t.hf_movies.limit(2)\n\n\n# db.drop('hf_movies')\n\n\n\ndb.create_table('../data/example.xlsx')\n\n\nsheet = db.t.example\nsheet\n\n\n\n\n\nCOLUMN1\nCOLUMN WITH SPACE\nCólumn name\n\n\n\n\n1\n1.3\na\n\n\n2\n1.3\nbn\n\n\n3\n1.3\nv\n\n\n4\n1.3\nsgf\n\n\n5\n1.3\nasd\n\n\n\n5 rows x  3 cols      DuckDBPyRelation BASE_TABLE chinook.main.example \n\n\n\n\n\ndb.drop('example')\n\n\ndb.create_table('../data/chinook.sqlite', filetype='sqlite', table_name='Customer', as_name='sqlite_Customer')\n\n\ndb.t.sqlite_Customer\n\n\n\n\n\nCustomerId\nFirstName\nLastName\nCompany\nAddress\nCity\nState\nCountry\nPostalCode\nPhone\nFax\nEmail\nSupportRepId\n\n\n\n\n1\nLuís\nGonçalves\nEmbraer - Empresa Brasileira de Aeronáutica S.A.\nAv. Brigadeiro Faria Lima, 2170\nSão José dos Campos\nSP\nBrazil\n12227-000\n+55 (12) 3923-5555\n+55 (12) 3923-5566\nluisg@embraer.com.br\n3\n\n\n2\nLeonie\nKöhler\nNone\nTheodor-Heuss-Straße 34\nStuttgart\nNone\nGermany\n70174\n+49 0711 2842222\nNone\nleonekohler@surfeu.de\n5\n\n\n3\nFrançois\nTremblay\nNone\n1498 rue Bélanger\nMontréal\nQC\nCanada\nH2G 1A7\n+1 (514) 721-4711\nNone\nftremblay@gmail.com\n3\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n58\nManoj\nPareek\nNone\n12,Community Centre\nDelhi\nNone\nIndia\n110017\n+91 0124 39883988\nNone\nmanoj.pareek@rediff.com\n3\n\n\n59\nPuja\nSrivastava\nNone\n3,Raj Bhavan Road\nBangalore\nNone\nIndia\n560001\n+91 080 22289999\nNone\npuja_srivastava@yahoo.in\n3\n\n\n\n59 rows x  13 cols      DuckDBPyRelation BASE_TABLE chinook.main.sqlite_Customer \n\n\n\n\ndb.drop('sqlite_Customer')\n\n::: {#cell-87 .cell 0=‘e’ 1=‘x’ 2=‘p’ 3=‘o’ 4=‘r’ 5=‘t’}\n@patch\ndef import_from(self:DuckDBPyConnection, filepath=None, pre='', suf='', schema=None, replace=None):\n    self.attach(filepath, catalog_name='import')\n    list =  self.tables.filter(\"catalog = 'import' and type='BASE TABLE'\").select('name').to_list()\n    self.sql('detach import')\n    schema = schema or self.schema\n    db.sql(f\"CREATE SCHEMA IF NOT EXISTS {schema}\")\n    for tbl in list: db.create_table(fileglob=filepath, filetype='sqlite', table_name=tbl, as_name=schema+'.'+pre+tbl+suf, replace=replace)\n:::\n\ndb.tables.show()\n\n┌─────────┬─────────┬───────────────┬────────────┬─────────────┐\n│ catalog │ schema  │     name      │    type    │   comment   │\n│ varchar │ varchar │    varchar    │  varchar   │   varchar   │\n├─────────┼─────────┼───────────────┼────────────┼─────────────┤\n│ chinook │ main    │ Album         │ BASE TABLE │ Album table │\n│ chinook │ main    │ Artist        │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Customer      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Employee      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Genre         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Invoice       │ BASE TABLE │ NULL        │\n│ chinook │ main    │ InvoiceLine   │ BASE TABLE │ NULL        │\n│ chinook │ main    │ MediaType     │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Playlist      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ PlaylistTrack │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Track         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ todos         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ a_view        │ VIEW       │ Just a view │\n│ chinook │ main    │ temp_view     │ VIEW       │ NULL        │\n├─────────┴─────────┴───────────────┴────────────┴─────────────┤\n│ 14 rows                                            5 columns │\n└──────────────────────────────────────────────────────────────┘\n\n\n\n\ndb.import_from('../data/chinook.sqlite', schema = 'cebola', replace=True)\n\n\ndb.tables.show()\n\n┌─────────┬─────────┬───────────────┬────────────┬─────────────┐\n│ catalog │ schema  │     name      │    type    │   comment   │\n│ varchar │ varchar │    varchar    │  varchar   │   varchar   │\n├─────────┼─────────┼───────────────┼────────────┼─────────────┤\n│ chinook │ main    │ Album         │ BASE TABLE │ Album table │\n│ chinook │ cebola  │ Album         │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Artist        │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Artist        │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Customer      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Customer      │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Employee      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Employee      │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Genre         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Genre         │ BASE TABLE │ NULL        │\n│    ·    │  ·      │   ·           │     ·      │  ·          │\n│    ·    │  ·      │   ·           │     ·      │  ·          │\n│    ·    │  ·      │   ·           │     ·      │  ·          │\n│ chinook │ main    │ MediaType     │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Playlist      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Playlist      │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ PlaylistTrack │ BASE TABLE │ NULL        │\n│ chinook │ main    │ PlaylistTrack │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Track         │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Track         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ todos         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ a_view        │ VIEW       │ Just a view │\n│ chinook │ main    │ temp_view     │ VIEW       │ NULL        │\n├─────────┴─────────┴───────────────┴────────────┴─────────────┤\n│ 25 rows (20 shown)                                 5 columns │\n└──────────────────────────────────────────────────────────────┘\n\n\n\n\ndb.drop('cebola.*')\ndb.detach('lite_main')\n\n\ndb.tables\n\n\n\n\n\ncatalog\nschema\nname\ntype\ncomment\n\n\n\n\nchinook\nmain\nAlbum\nBASE TABLE\nAlbum table\n\n\nchinook\nmain\nArtist\nBASE TABLE\nNone\n\n\nchinook\nmain\nCustomer\nBASE TABLE\nNone\n\n\n...\n...\n...\n...\n...\n\n\nchinook\nmain\na_view\nVIEW\nJust a view\n\n\nchinook\nmain\ntemp_view\nVIEW\nNone\n\n\n\n14 rows x  5 cols      DuckDBPyRelation",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "00_core.html#export--",
    "href": "00_core.html#export--",
    "title": "Source",
    "section": "export -",
    "text": "export -\n::: {#cell-94 .cell 0=‘h’ 1=‘i’ 2=‘d’ 3=‘e’}\nimport nbdev; nbdev.nbdev_export()\n:::",
    "crumbs": [
      "Source"
    ]
  }
]