[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "fastduck",
    "section": "",
    "text": "fastduck provides some development experience improvements for the standard duckdb python API.",
    "crumbs": [
      "fastduck"
    ]
  },
  {
    "objectID": "index.html#install",
    "href": "index.html#install",
    "title": "fastduck",
    "section": "Install",
    "text": "Install\npip install fastduck",
    "crumbs": [
      "fastduck"
    ]
  },
  {
    "objectID": "index.html#how-to-use",
    "href": "index.html#how-to-use",
    "title": "fastduck",
    "section": "How to use",
    "text": "How to use\nimport fastduck as fuck\n\nfrom fastduck import database\n\n\ndb = database('../data/chinook.duckdb')\ndb\n\nDuckDBPyConnection (chinook_main)\n\n\n\ndt = db.t\ndt\n\n(chinook_main) Tables: Album, Artist, Customer, Employee, Genre, Invoice, InvoiceLine, MediaType, Playlist, PlaylistTrack, Track, todos\n\n\nYou can use this to grab a single table…\n\nartist = dt.Artist\nartist\n\n\n\n\n\nArtistId\nName\n\n\n\n\n1\nAC/DC\n\n\n2\nAccept\n\n\n3\nAerosmith\n\n\n...\n...\n\n\n274\nNash Ensemble\n\n\n275\nPhilip Glass Ensemble\n\n\n\n275 rows x  2 cols      DuckDBPyRelation BASE_TABLE chinook.main.Artist \n\n\n\n\ncustomer = dt['Customer']\ncustomer\n\n\n\n\n\nCustomerId\nFirstName\nLastName\nCompany\nAddress\nCity\nState\nCountry\nPostalCode\nPhone\nFax\nEmail\nSupportRepId\n\n\n\n\n1\nLuís\nGonçalves\nEmbraer - Empresa Brasileira de Aeronáutica S.A.\nAv. Brigadeiro Faria Lima, 2170\nSão José dos Campos\nSP\nBrazil\n12227-000\n+55 (12) 3923-5555\n+55 (12) 3923-5566\nluisg@embraer.com.br\n3\n\n\n2\nLeonie\nKöhler\nNone\nTheodor-Heuss-Straße 34\nStuttgart\nNone\nGermany\n70174\n+49 0711 2842222\nNone\nleonekohler@surfeu.de\n5\n\n\n3\nFrançois\nTremblay\nNone\n1498 rue Bélanger\nMontréal\nQC\nCanada\nH2G 1A7\n+1 (514) 721-4711\nNone\nftremblay@gmail.com\n3\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n58\nManoj\nPareek\nNone\n12,Community Centre\nDelhi\nNone\nIndia\n110017\n+91 0124 39883988\nNone\nmanoj.pareek@rediff.com\n3\n\n\n59\nPuja\nSrivastava\nNone\n3,Raj Bhavan Road\nBangalore\nNone\nIndia\n560001\n+91 080 22289999\nNone\npuja_srivastava@yahoo.in\n3\n\n\n\n59 rows x  13 cols      DuckDBPyRelation BASE_TABLE chinook.main.Customer \n\n\n\n… or multiple tables at once:\n\ndt['Artist', 'Album', 'Genre']\n\n[DuckDBPyRelation BASE TABLE chinook.main.Artist \n ,\n DuckDBPyRelation BASE TABLE chinook.main.Album \n ,\n DuckDBPyRelation BASE TABLE chinook.main.Genre \n ]\n\n\nIt also provides auto-complete in Jupyter, IPython and nearly any other interactive Python environment:\n\n\n\nAutocomplete in Jupyter\n\n\nYou can check if a table is in the database already:\n\n'Artist' in dt\n\nTrue\n\n\nColumn work in a similar way to tables, using the c property:\n\nac = artist.c\nac, artist.columns\n\n(chinook.main.Artist Columns: ArtistId, Name, ['ArtistId', 'Name'])\n\n\nAuto-complete works for columns too:\n\n\n\nColumns autocomplete in Jupyter\n\n\nThe tables and views of a database got some interesting new attributes….\n\nartist.meta\n\n{'base': DuckDBPyConnection (chinook_main),\n 'catalog': 'chinook',\n 'schema': 'main',\n 'name': 'Artist',\n 'type': 'BASE TABLE',\n 'comment': None,\n 'shape': (275, 2)}\n\n\n\nartist.model\n\n[{'name': 'ArtistId',\n  'type': 'INTEGER',\n  'nullable': False,\n  'default': None,\n  'pk': True},\n {'name': 'Name',\n  'type': 'VARCHAR',\n  'nullable': True,\n  'default': None,\n  'pk': False}]\n\n\n\nartist.cls, type(artist.cls)\n\n(fastduck.core.Artist, type)\n\n\nduckdb replacement scans keep working and are wonderful for usage in SQL statements:\n\ndb.sql(\"select * from artist where artist.Name like 'AC/%'\")\n\n\n\n\n\nArtistId\nName\n\n\n\n\n1\nAC/DC\n\n\n\n1 rows x  2 cols      DuckDBPyRelation   \n\n\n\nYou can view the results of a query as records\n\ndb.sql(\"select * from artist where artist.Name like 'AC/%'\").to_recs()\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\nor as a list of lists\n\ndb.sql(\"select * from artist where artist.Name like 'AC/%'\").to_list()\n\n[[1, 'AC/DC']]\n\n\nAnd you there is also an alias for sql with to_recs simply called q\n\ndb.q(\"select * from artist where artist.Name like 'AC/%'\")\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\n\nDataclass support\nAs we briefly saw, a dataclass type with the names, types and defaults of the table is added to the Relation:\n\nabm = db.t.Album\nart = db.t.Artist\nacca_sql = f\"\"\"\nselect abm.* \nfrom abm join art using (ArtistID)\nwhere art.Name like 'AC/%'\n\"\"\"\nacca_dacca = db.q(acca_sql)\nacca_dacca\n\n[{'AlbumId': 1,\n  'Title': 'For Those About To Rock We Salute You',\n  'ArtistId': 1},\n {'AlbumId': 4, 'Title': 'Let There Be Rock', 'ArtistId': 1}]\n\n\n\nlet_b_rock_obj = abm.cls(**acca_dacca[-1])\nlet_b_rock_obj\n\nAlbum(AlbumId=4, Title='Let There Be Rock', ArtistId=1)\n\n\nYou can get the definition of the dataclass using fastcore’s dataclass_src – everything is treated as nullable, in order to handle auto-generated database values:\n\nfrom fastcore.xtras import hl_md, dataclass_src\n\nsrc = dataclass_src(db.t.Album.cls)\nhl_md(src, 'python')\n\n@dataclass\nclass Album:\n    AlbumId: int32 = None\n    Title: str = None\n    ArtistId: int32 = None",
    "crumbs": [
      "fastduck"
    ]
  },
  {
    "objectID": "00_core.html",
    "href": "00_core.html",
    "title": "Source",
    "section": "",
    "text": "Wrapping DuckDB Python API\nWhen you import duckdb, there are two main concepts that you have to handle:\nA DuckDBPyConnection represents a connection to a DuckDB database in a file or memory\nDuckDB API has no concept of a Database, only of a connection that may envolve different attached databases (or catalogs) and schemas.\nA Catalog is just a holder for schemas, and schemas hold catalog entries, like tables, views, functions, types, etc..\nWe will change this behaviour in a bit…\nA DuckDBPyRelation represents a query. It is a table-like object that will be lazy executed and can be queried further.\nOnce it’s executed then yes, it contains the result set.\nBut when further projections are made on it, that result set is not used, the projections are just done on top of the original query as a subquery\nduckdb.table('tbl').sql(\"select a\")\nReally becomes, in essence: select a from (select * from tbl)\ndb = duckdb.connect()\ndb.sql(f\"FROM duckdb_tables()\")\n\n┌───────────────┬──────────────┬─────────────┬────────────┬───┬─────────────┬──────────────────────┬─────────┐\n│ database_name │ database_oid │ schema_name │ schema_oid │ … │ index_count │ check_constraint_c…  │   sql   │\n│    varchar    │    int64     │   varchar   │   int64    │   │    int64    │        int64         │ varchar │\n├───────────────┴──────────────┴─────────────┴────────────┴───┴─────────────┴──────────────────────┴─────────┤\n│                                                   0 rows                                                   │\n└────────────────────────────────────────────────────────────────────────────────────────────────────────────┘\ntype(db.sql(f\"SELECT table_name FROM duckdb_tables()\"))\n\nduckdb.duckdb.DuckDBPyRelation\ndb.close()",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "00_core.html#improving-connection",
    "href": "00_core.html#improving-connection",
    "title": "Source",
    "section": "Improving Connection",
    "text": "Improving Connection\nWe want the developer to understand the connection as a database.\n\nimport duckdb\n\nconn = duckdb.connect()\nbecomes\n\nfrom fastduck import database\ndb = database()\nBy acessing the same Python API using fastduck, the developer shall get some niceties.\n\n\nPyCapsule.connect\nconnect(database: str = ‘:memory:’, read_only: bool = False, config: dict = None) -&gt; duckdb.DuckDBPyConnection\nCreate a DuckDB database instance. Can take a database file name to read/write persistent data and a read_only flag if no changes are desired\nLet’s start by simplifying the access to some information on the current catalog and schema in the connection.\n\ndb = database('../data/chinook.duckdb')\n\n\nsource\n\n\nDuckDBPyConnection.q\n\n DuckDBPyConnection.q (*args, **kwargs)\n\nRun a query and return the result as a list of records\n\nsource\n\n\nDuckDBPyRelation.to_list\n\n DuckDBPyRelation.to_list ()\n\nThe relation as a list\n\nsource\n\n\nDuckDBPyRelation.to_recs\n\n DuckDBPyRelation.to_recs ()\n\nThe relation as a list of records\n\nsource\n\n\nDuckDBPyRelation.name\n\n DuckDBPyRelation.name ()\n\n\nsource\n\n\nDuckDBPyConnection.schema\n\n DuckDBPyConnection.schema ()\n\n\nsource\n\n\nDuckDBPyConnection.catalog\n\n DuckDBPyConnection.catalog ()\n\n\nalbum = db.sql(\"select * from Album\")\nalbum['AlbumId', 'Title'].limit(5)\n\n┌─────────┬───────────────────────────────────────┐\n│ AlbumId │                 Title                 │\n│  int32  │                varchar                │\n├─────────┼───────────────────────────────────────┤\n│       1 │ For Those About To Rock We Salute You │\n│       2 │ Balls to the Wall                     │\n│       3 │ Restless and Wild                     │\n│       4 │ Let There Be Rock                     │\n│       5 │ Big Ones                              │\n└─────────┴───────────────────────────────────────┘\n\n\n\ndb.table('Album')['AlbumId', 'Title'].limit(2).to_recs()\n\n[{'AlbumId': 1, 'Title': 'For Those About To Rock We Salute You'},\n {'AlbumId': 2, 'Title': 'Balls to the Wall'}]\n\n\nWe also need a way to know the tables in the database.\n\nsource\n\n\nDuckDBPyConnection.schemas\n\n DuckDBPyConnection.schemas ()\n\nReturns the schemas in the database\n\nsource\n\n\nDuckDBPyConnection.base_tables\n\n DuckDBPyConnection.base_tables ()\n\nReturns the base tables in current schema\n\nsource\n\n\nDuckDBPyConnection.views\n\n DuckDBPyConnection.views ()\n\nReturns the views in current schema\n\nsource\n\n\nDuckDBPyConnection.tables\n\n DuckDBPyConnection.tables ()\n\nReturns the tables in the database\n\ndb.schemas\n\n┌────────────────┐\n│ catalog_schema │\n│    varchar     │\n├────────────────┤\n│ chinook_main   │\n└────────────────┘\n\n\n\ndb.views.limit(3)\n\n┌─────────┬─────────┬───────────┬─────────┬─────────────┐\n│ catalog │ schema  │   name    │  type   │   comment   │\n│ varchar │ varchar │  varchar  │ varchar │   varchar   │\n├─────────┼─────────┼───────────┼─────────┼─────────────┤\n│ chinook │ main    │ a_view    │ VIEW    │ Just a view │\n│ chinook │ main    │ temp_view │ VIEW    │ NULL        │\n└─────────┴─────────┴───────────┴─────────┴─────────────┘\n\n\nThe functions bellow add some utilities that are useful for working with tables and views in a database.\n\nsource\n\n\nDuckDBPyConnection.datamodel\n\n DuckDBPyConnection.datamodel (table_name:str)\n\nReturns the data model of a table or view. The columns names, types, nullable status, default value and primary key status.\n\ndb.datamodel('Artist')\n\n[{'name': 'ArtistId',\n  'type': 'INTEGER',\n  'nullable': False,\n  'default': None,\n  'pk': True},\n {'name': 'Name',\n  'type': 'VARCHAR',\n  'nullable': True,\n  'default': None,\n  'pk': False}]\n\n\n\nsource\n\n\nDuckDBPyConnection.dataclass\n\n DuckDBPyConnection.dataclass (table_name:str, pref='', suf='',\n                               cls_name:str=None)\n\nCreates a dataclass type from a table or view in the database.\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\ntable_name\nstr\n\ntable or view name\n\n\npref\nstr\n\nprefix to add to the field names\n\n\nsuf\nstr\n\nsuffix to add to the field names\n\n\ncls_name\nstr\nNone\ndefaults to table_name\n\n\nReturns\ntype\n\n\n\n\n\n\nsource\n\n\nclean\n\n clean (s)\n\n\nsource\n\n\nconvertTypes\n\n convertTypes (s:str)\n\nConvert DuckDB types to Python and Numpy types\n\nartist_dc = db.dataclass('Artist')\nsrc = dataclass_src(artist_dc)\nhl_md(src, 'python') # fix error in nbdev_prepare\n\n@dataclass\nclass Artist:\n    ArtistId: int32 = None\n    Name: str | None = None\n\n\n\nacdc = db.sql(f\"select * from artist where artist.Name like 'AC/%'\").df().to_dict(orient='records')\nacdc\n\n[{'ArtistId': 1, 'Name': 'AC/DC'}]\n\n\n\nacdc_object = artist_dc(**acdc[0])\nacdc_object\n\nArtist(ArtistId=1, Name='AC/DC')",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "00_core.html#relation-utilities",
    "href": "00_core.html#relation-utilities",
    "title": "Source",
    "section": "Relation utilities",
    "text": "Relation utilities\nOnce we know that a certain DuckDBPyRelation is a table (or view), we can also make it keep some valuable props.\n\nsource\n\nDuckDBPyConnection.table\n\n DuckDBPyConnection.table (name:str, schema:str=None, catalog:str=None)\n\n\nsource\n\n\nDuckDBPyRelation.rel\n\n DuckDBPyRelation.rel ()\n\n\nsource\n\n\nDuckDBPyRelation.meta\n\n DuckDBPyRelation.meta ()\n\n\nsource\n\n\nDuckDBPyRelation.model\n\n DuckDBPyRelation.model ()\n\n\nsource\n\n\nDuckDBPyRelation.cls\n\n DuckDBPyRelation.cls ()\n\n\nsource\n\n\ncreate_prop\n\n create_prop (c, name, f)\n\n\nsource\n\n\ncreate_patch_property\n\n create_patch_property (name)\n\n\nsource\n\n\ncustom_dir\n\n custom_dir (c, add)\n\n\nsource\n\n\nDuckDBPyRelation.c\n\n DuckDBPyRelation.c ()\n\nColumn autocomplete\n\ndb\n\n&lt;duckdb.duckdb.DuckDBPyConnection at 0x16b97fd70&gt;\n\n\n\n\nAutocomplete\nWe want an easy access to table information.\nlike db.tables should work similar to the .table cli command.\n\nsource\n\n\nDuckDBPyConnection.shh\n\n DuckDBPyConnection.shh ()\n\n\nsource\n\n\nDuckDBPyConnection.fns\n\n DuckDBPyConnection.fns ()\n\n\nsource\n\n\nDuckDBPyConnection.v\n\n DuckDBPyConnection.v ()\n\nAutocomplete functonality for views\n\nsource\n\n\nDuckDBPyConnection.t\n\n DuckDBPyConnection.t ()\n\nAutocomplete functonality for tables\n\nsource\n\n\nDuckDBPyConnection.s\n\n DuckDBPyConnection.s ()\n\nAutocomplete functonality for schemas\n\nsource\n\n\nDuckDBPyConnection.get_schema\n\n DuckDBPyConnection.get_schema (catalog_schema:str)\n\n\nsource\n\n\nDuckDBPyConnection.use\n\n DuckDBPyConnection.use (catalog_schema:str=None, catalog:str=None,\n                         schema=None)\n\n\nsource\n\n\nidentity\n\n identity (x)\n\n\nsource\n\n\nnoop\n\n noop (*args, **kwargs)\n\n:::\n\n\n\nAutocomplete in Jupyter\n\n\n:::\n\na = db.t.Album.c['AlbumId', 'Title'].limit(4)\na\n\n┌─────────┬───────────────────────────────────────┐\n│ AlbumId │                 Title                 │\n│  int32  │                varchar                │\n├─────────┼───────────────────────────────────────┤\n│       1 │ For Those About To Rock We Salute You │\n│       2 │ Balls to the Wall                     │\n│       3 │ Restless and Wild                     │\n│       4 │ Let There Be Rock                     │\n└─────────┴───────────────────────────────────────┘\n\n\nLet’s also improve the representation of Relations.\n\ndb.s.chinook_main.t.Album\n\n┌─────────┬─────────────────────────────────────────────────────────────────────┬──────────┐\n│ AlbumId │                                Title                                │ ArtistId │\n│  int32  │                               varchar                               │  int32   │\n├─────────┼─────────────────────────────────────────────────────────────────────┼──────────┤\n│       1 │ For Those About To Rock We Salute You                               │        1 │\n│       2 │ Balls to the Wall                                                   │        2 │\n│       3 │ Restless and Wild                                                   │        2 │\n│       4 │ Let There Be Rock                                                   │        1 │\n│       5 │ Big Ones                                                            │        3 │\n│       6 │ Jagged Little Pill                                                  │        4 │\n│       7 │ Facelift                                                            │        5 │\n│       8 │ Warner 25 Anos                                                      │        6 │\n│       9 │ Plays Metallica By Four Cellos                                      │        7 │\n│      10 │ Audioslave                                                          │        8 │\n│       · │     ·                                                               │        · │\n│       · │     ·                                                               │        · │\n│       · │     ·                                                               │        · │\n│     338 │ Nielsen: The Six Symphonies                                         │      267 │\n│     339 │ Great Recordings of the Century: Paganini's 24 Caprices             │      268 │\n│     340 │ Liszt - 12 Études D'Execution Transcendante                         │      269 │\n│     341 │ Great Recordings of the Century - Shubert: Schwanengesang, 4 Lieder │      270 │\n│     342 │ Locatelli: Concertos for Violin, Strings and Continuo, Vol. 3       │      271 │\n│     343 │ Respighi:Pines of Rome                                              │      226 │\n│     344 │ Schubert: The Late String Quartets & String Quintet (3 CD's)        │      272 │\n│     345 │ Monteverdi: L'Orfeo                                                 │      273 │\n│     346 │ Mozart: Chamber Music                                               │      274 │\n│     347 │ Koyaanisqatsi (Soundtrack from the Motion Picture)                  │      275 │\n├─────────┴─────────────────────────────────────────────────────────────────────┴──────────┤\n│ 347 rows (20 shown)                                                            3 columns │\n└──────────────────────────────────────────────────────────────────────────────────────────┘\n\n\n\nDuckDBPyRelation._repr_markdown_??\n\nObject `DuckDBPyRelation._repr_markdown_` not found.\n\n\n\nprint(a.df().to_markdown(index=False))\n\n|   AlbumId | Title                                 |\n|----------:|:--------------------------------------|\n|         1 | For Those About To Rock We Salute You |\n|         2 | Balls to the Wall                     |\n|         3 | Restless and Wild                     |\n|         4 | Let There Be Rock                     |\n\n\n\ndb.tables.show()\n\n┌─────────┬─────────┬───────────────┬────────────┬─────────────┐\n│ catalog │ schema  │     name      │    type    │   comment   │\n│ varchar │ varchar │    varchar    │  varchar   │   varchar   │\n├─────────┼─────────┼───────────────┼────────────┼─────────────┤\n│ chinook │ main    │ Album         │ BASE TABLE │ Album table │\n│ chinook │ main    │ Artist        │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Customer      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Employee      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Genre         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Invoice       │ BASE TABLE │ NULL        │\n│ chinook │ main    │ InvoiceLine   │ BASE TABLE │ NULL        │\n│ chinook │ main    │ MediaType     │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Playlist      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ PlaylistTrack │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Track         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ todos         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ a_view        │ VIEW       │ Just a view │\n│ chinook │ main    │ temp_view     │ VIEW       │ NULL        │\n├─────────┴─────────┴───────────────┴────────────┴─────────────┤\n│ 14 rows                                            5 columns │\n└──────────────────────────────────────────────────────────────┘\n\n\n\n\ndb.v.a_view\n\n\n\n\n\nTrackId\nName\nAlbumId\nMediaTypeId\nGenreId\nComposer\nMilliseconds\nBytes\nUnitPrice\n\n\n\n\n1\nFor Those About To Rock (We Salute You)\n1\n1\n1\nAngus Young, Malcolm Young, Brian Johnson\n343719\n11170334\n0.98\n\n\n2\nBalls to the Wall\n2\n2\n1\nNone\n342562\n5510424\n0.98\n\n\n3\nFast As a Shark\n3\n2\n1\nF. Baltes, S. Kaufman, U. Dirkscneider & W. Hoffman\n230619\n3990994\n0.98\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n3502\nQuintet for Horn, Violin, 2 Violas, and Cello in E Flat Major, K. 407/386c: III. Allegro\n346\n2\n24\nWolfgang Amadeus Mozart\n221331\n3665114\n0.98\n\n\n3503\nKoyaanisqatsi\n347\n2\n10\nPhilip Glass\n206005\n3305164\n0.98\n\n\n\n3503 rows x  9 cols      DuckDBPyRelation VIEW chinook.main.a_view Just a view\n\n\n\n\n\ndb.sql('select * from Album')\n\n\n\n\n\nAlbumId\nTitle\nArtistId\n\n\n\n\n1\nFor Those About To Rock We Salute You\n1\n\n\n2\nBalls to the Wall\n2\n\n\n3\nRestless and Wild\n2\n\n\n...\n...\n...\n\n\n346\nMozart: Chamber Music\n274\n\n\n347\nKoyaanisqatsi (Soundtrack from the Motion Picture)\n275\n\n\n\n347 rows x  3 cols      DuckDBPyRelation   \n\n\n\n\ndb.t.Genre\n\n\n\n\n\nGenreId\nName\n\n\n\n\n1\nRock\n\n\n2\nJazz\n\n\n3\nMetal\n\n\n...\n...\n\n\n24\nClassical\n\n\n25\nOpera\n\n\n\n25 rows x  2 cols      DuckDBPyRelation BASE_TABLE chinook.main.Genre \n\n\n\n\na\n\n\n\n\n\nAlbumId\nTitle\n\n\n\n\n1\nFor Those About To Rock We Salute You\n\n\n2\nBalls to the Wall\n\n\n3\nRestless and Wild\n\n\n4\nLet There Be Rock\n\n\n\n4 rows x  2 cols      DuckDBPyRelation  chinook.main.Album \n\n\n\n\nReplacement Scans\nYou may be asking yourself why I am patching DuckDBPyRelation and DuckDBPyConnection instead of subclassing them. The problem is that these classes do not allow subclassing. They do not implement __init__.\nWe could have create our own classes like Database and Table and just wrap DuckDBPy objects. But then we would loose a very nice feature of the PyRelation objects…..\nreplacement scans.\n\na = db.t.Album\n\n\ndb.sql(\"select * from a\")\n\n\n\n\n\nAlbumId\nTitle\nArtistId\n\n\n\n\n1\nFor Those About To Rock We Salute You\n1\n\n\n2\nBalls to the Wall\n2\n\n\n3\nRestless and Wild\n2\n\n\n...\n...\n...\n\n\n346\nMozart: Chamber Music\n274\n\n\n347\nKoyaanisqatsi (Soundtrack from the Motion Picture)\n275\n\n\n\n347 rows x  3 cols      DuckDBPyRelation   \n\n\n\nI did not had to use a f-string and pass the variable. DuckDBPy objects (as well as Pandas and Polars Dataframes, Arrow tables, and Datasets) are replaced in the query automagically.\n\ndb.sql(f\"select * from {a}\")\n\n\n\n\n\nAlbumId\nTitle\nArtistId\n\n\n\n\n1\nFor Those About To Rock We Salute You\n1\n\n\n2\nBalls to the Wall\n2\n\n\n3\nRestless and Wild\n2\n\n\n...\n...\n...\n\n\n346\nMozart: Chamber Music\n274\n\n\n347\nKoyaanisqatsi (Soundtrack from the Motion Picture)\n275\n\n\n\n347 rows x  3 cols      DuckDBPyRelation   \n\n\n\n\nstr(a)\n\n'chinook.main.Album'\n\n\n\ndb.tables\n\n\n\n\n\ncatalog\nschema\nname\ntype\ncomment\n\n\n\n\nchinook\nmain\nAlbum\nBASE TABLE\nAlbum table\n\n\nchinook\nmain\nArtist\nBASE TABLE\nNone\n\n\nchinook\nmain\nCustomer\nBASE TABLE\nNone\n\n\n...\n...\n...\n...\n...\n\n\nchinook\nmain\na_view\nVIEW\nJust a view\n\n\nchinook\nmain\ntemp_view\nVIEW\nNone\n\n\n\n14 rows x  5 cols      DuckDBPyRelation",
    "crumbs": [
      "Source"
    ]
  },
  {
    "objectID": "00_core.html#database-management",
    "href": "00_core.html#database-management",
    "title": "Source",
    "section": "Database management",
    "text": "Database management\n\nAttach, Detach and Use\n\nsource\n\n\nDuckDBPyConnection.attach\n\nsource\n\n\nInvalidPathError\nCommon base class for all non-exit exceptions.\n\nsource\n\n\nRemoteSqliteError\nCommon base class for all non-exit exceptions.\n\n@patch\ndef detach(self: DuckDBPyConnection, catalog_name) -&gt; None:\n    if catalog_name in self.schemas.to_list(): self.sql(f\"DETACH {catalog_name.split('_')[0]}\")\n\n\ndb.attach('../data/chinook.sqlite', catalog_name='lite')\n\n\ndb.schemas\n\n\n\n\n\ncatalog_schema\n\n\n\n\nlite_main\n\n\nchinook_main\n\n\n\n2 rows x  1 cols      DuckDBPyRelation   \n\n\n\n\ndb.detach('lite_main')\n\n\nDrop\n\nsource\n\n\n\nDuckDBPyConnection.drop\n\n DuckDBPyConnection.drop (pattern:str)\n\nDrop a table or view\n\nsource\n\n\nfind_matches\n\n find_matches (pattern:str, items:List[str])\n\n\ndb.tables.show()\n\n┌─────────┬─────────┬───────────────┬────────────┬─────────────┐\n│ catalog │ schema  │     name      │    type    │   comment   │\n│ varchar │ varchar │    varchar    │  varchar   │   varchar   │\n├─────────┼─────────┼───────────────┼────────────┼─────────────┤\n│ chinook │ main    │ Album         │ BASE TABLE │ Album table │\n│ chinook │ main    │ Artist        │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Customer      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Employee      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Genre         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Invoice       │ BASE TABLE │ NULL        │\n│ chinook │ main    │ InvoiceLine   │ BASE TABLE │ NULL        │\n│ chinook │ main    │ MediaType     │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Playlist      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ PlaylistTrack │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Track         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ todos         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ a_view        │ VIEW       │ Just a view │\n│ chinook │ main    │ temp_view     │ VIEW       │ NULL        │\n├─────────┴─────────┴───────────────┴────────────┴─────────────┤\n│ 14 rows                                            5 columns │\n└──────────────────────────────────────────────────────────────┘\n\n\n\n\ndb.drop('non_existent')\n\n\nCreate Table or View\n\nsource\n\n\n\nDuckDBPyConnection.create_view\n\n DuckDBPyConnection.create_view (fileglob:str,\n                                 view_name:Optional[str]=None, filetype:Op\n                                 tional[Literal['csv','xlsx','json','parqu\n                                 et','sqlite']]=None, replace:bool=False,\n                                 as_name:Optional[str]=None, *args,\n                                 **kwargs)\n\nCreate a view from a file\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfileglob\nstr\n\nfile path or glob\n\n\nview_name\nOptional[str]\nNone\nview name\n\n\nfiletype\nOptional[Literal[‘csv’, ‘xlsx’, ‘json’, ‘parquet’, ‘sqlite’]]\nNone\nfile type\n\n\nreplace\nbool\nFalse\nreplace existing view\n\n\nas_name\nOptional[str]\nNone\n\n\n\nargs\n\n\n\n\n\nkwargs\n\n\n\n\n\n\n\nsource\n\n\nDuckDBPyConnection.create_table\n\n DuckDBPyConnection.create_table (fileglob:str,\n                                  table_name:Optional[str]=None, filetype:\n                                  Optional[Literal['csv','xlsx','json','pa\n                                  rquet','sqlite']]=None,\n                                  as_name:Optional[str]=None,\n                                  replace:bool=False, *args, **kwargs)\n\nCreate a table from a file\n\n\n\n\n\n\n\n\n\n\nType\nDefault\nDetails\n\n\n\n\nfileglob\nstr\n\nfile path or glob\n\n\ntable_name\nOptional[str]\nNone\ntable name\n\n\nfiletype\nOptional[Literal[‘csv’, ‘xlsx’, ‘json’, ‘parquet’, ‘sqlite’]]\nNone\nfile type\n\n\nas_name\nOptional[str]\nNone\n\n\n\nreplace\nbool\nFalse\nreplace existing table\n\n\nargs\n\n\n\n\n\nkwargs\n\n\n\n\n\n\n\ndb.create_table('../data/username.latin1.csv', 'latin', replace=True)\ndb.tables\n\n\n\n\n\ncatalog\nschema\nname\ntype\ncomment\n\n\n\n\nchinook\nmain\nAlbum\nBASE TABLE\nAlbum table\n\n\nchinook\nmain\nArtist\nBASE TABLE\nNone\n\n\nchinook\nmain\nCustomer\nBASE TABLE\nNone\n\n\n...\n...\n...\n...\n...\n\n\nchinook\nmain\na_view\nVIEW\nJust a view\n\n\nchinook\nmain\ntemp_view\nVIEW\nNone\n\n\n\n15 rows x  5 cols      DuckDBPyRelation   \n\n\n\n\ndb.create_view('../data/username.latin1.csv', 'latin1view', replace=True)\n\n\ndb.tables.filter(f\"name like '%latin%'\")\n#  db.sql(\"select distinct database_name, schema_name, table_name, column_name from duckdb_columns()\")\n# db.sql(\"attach database '../data/chinook.sqlite' as sqlite\")\n\n\n\n\n\ncatalog\nschema\nname\ntype\ncomment\n\n\n\n\nchinook\nmain\nlatin\nBASE TABLE\nNone\n\n\nchinook\nmain\nlatin1view\nBASE TABLE\nNone\n\n\n\n2 rows x  5 cols      DuckDBPyRelation   \n\n\n\n\ndb.drop('latin1view')\ndb.drop('latin')\n\n\n# from fastcore.test import test_fail\n# test_fail(db.drop, 'banana') # fix error in nbdev_prepare\n\n\ndb.create_table('https://jsonplaceholder.typicode.com/todos/', 'todos', filetype='json', replace=True)\n\n\ndb.t.todos.limit(10)\n\n\n\n\n\nuserId\nid\ntitle\ncompleted\n\n\n\n\n1\n1\ndelectus aut autem\nFalse\n\n\n1\n2\nquis ut nam facilis et officia qui\nFalse\n\n\n1\n3\nfugiat veniam minus\nFalse\n\n\n...\n...\n...\n...\n\n\n1\n9\nmolestiae perspiciatis ipsa\nFalse\n\n\n1\n10\nillo est ratione doloremque quia maiores aut\nTrue\n\n\n\n10 rows x  4 cols      DuckDBPyRelation  chinook.main.todos \n\n\n\n\n# db.create_table('https://huggingface.co/datasets/ibm/duorc/resolve/refs%2Fconvert%2Fparquet/ParaphraseRC/test/0000.parquet', 'hf_movies')\n\n\n# db.t.hf_movies.limit(2)\n\n\n# db.drop('hf_movies')\n\n\ndb.create_table('../data/example.xlsx')\n\n\nsheet = db.t.example\nsheet\n\n\n\n\n\nCOLUMN1\nCOLUMN WITH SPACE\nCólumn name\n\n\n\n\n1\n1.3\na\n\n\n2\n1.3\nbn\n\n\n3\n1.3\nv\n\n\n4\n1.3\nsgf\n\n\n5\n1.3\nasd\n\n\n\n5 rows x  3 cols      DuckDBPyRelation BASE_TABLE chinook.main.example \n\n\n\n\ndb.drop('example')\n\n\ndb.create_table('../data/chinook.sqlite', filetype='sqlite', table_name='Customer', as_name='sqlite_Customer')\n\n\ndb.t.sqlite_Customer\n\n\n\n\n\nCustomerId\nFirstName\nLastName\nCompany\nAddress\nCity\nState\nCountry\nPostalCode\nPhone\nFax\nEmail\nSupportRepId\n\n\n\n\n1\nLuís\nGonçalves\nEmbraer - Empresa Brasileira de Aeronáutica S.A.\nAv. Brigadeiro Faria Lima, 2170\nSão José dos Campos\nSP\nBrazil\n12227-000\n+55 (12) 3923-5555\n+55 (12) 3923-5566\nluisg@embraer.com.br\n3\n\n\n2\nLeonie\nKöhler\nNone\nTheodor-Heuss-Straße 34\nStuttgart\nNone\nGermany\n70174\n+49 0711 2842222\nNone\nleonekohler@surfeu.de\n5\n\n\n3\nFrançois\nTremblay\nNone\n1498 rue Bélanger\nMontréal\nQC\nCanada\nH2G 1A7\n+1 (514) 721-4711\nNone\nftremblay@gmail.com\n3\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n58\nManoj\nPareek\nNone\n12,Community Centre\nDelhi\nNone\nIndia\n110017\n+91 0124 39883988\nNone\nmanoj.pareek@rediff.com\n3\n\n\n59\nPuja\nSrivastava\nNone\n3,Raj Bhavan Road\nBangalore\nNone\nIndia\n560001\n+91 080 22289999\nNone\npuja_srivastava@yahoo.in\n3\n\n\n\n59 rows x  13 cols      DuckDBPyRelation BASE_TABLE chinook.main.sqlite_Customer \n\n\n\n\ndb.drop('sqlite_Customer')\n\n\nsource\n\n\nDuckDBPyConnection.import_from\n\n DuckDBPyConnection.import_from (filepath=None, pre='', suf='',\n                                 schema=None, replace=None)\n\n\ndb.tables.show()\n\n┌─────────┬─────────┬───────────────┬────────────┬─────────────┐\n│ catalog │ schema  │     name      │    type    │   comment   │\n│ varchar │ varchar │    varchar    │  varchar   │   varchar   │\n├─────────┼─────────┼───────────────┼────────────┼─────────────┤\n│ chinook │ main    │ Album         │ BASE TABLE │ Album table │\n│ chinook │ main    │ Artist        │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Customer      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Employee      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Genre         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Invoice       │ BASE TABLE │ NULL        │\n│ chinook │ main    │ InvoiceLine   │ BASE TABLE │ NULL        │\n│ chinook │ main    │ MediaType     │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Playlist      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ PlaylistTrack │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Track         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ todos         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ a_view        │ VIEW       │ Just a view │\n│ chinook │ main    │ temp_view     │ VIEW       │ NULL        │\n├─────────┴─────────┴───────────────┴────────────┴─────────────┤\n│ 14 rows                                            5 columns │\n└──────────────────────────────────────────────────────────────┘\n\n\n\n\ndb.import_from('../data/chinook.sqlite', schema = 'cebola', replace=True)\n\n\ndb.tables.show()\n\n┌─────────┬─────────┬───────────────┬────────────┬─────────────┐\n│ catalog │ schema  │     name      │    type    │   comment   │\n│ varchar │ varchar │    varchar    │  varchar   │   varchar   │\n├─────────┼─────────┼───────────────┼────────────┼─────────────┤\n│ chinook │ main    │ Album         │ BASE TABLE │ Album table │\n│ chinook │ cebola  │ Album         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Artist        │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Artist        │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Customer      │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Customer      │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Employee      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Employee      │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Genre         │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Genre         │ BASE TABLE │ NULL        │\n│    ·    │  ·      │   ·           │     ·      │  ·          │\n│    ·    │  ·      │   ·           │     ·      │  ·          │\n│    ·    │  ·      │   ·           │     ·      │  ·          │\n│ chinook │ main    │ MediaType     │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Playlist      │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Playlist      │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ PlaylistTrack │ BASE TABLE │ NULL        │\n│ chinook │ main    │ PlaylistTrack │ BASE TABLE │ NULL        │\n│ chinook │ main    │ Track         │ BASE TABLE │ NULL        │\n│ chinook │ cebola  │ Track         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ todos         │ BASE TABLE │ NULL        │\n│ chinook │ main    │ a_view        │ VIEW       │ Just a view │\n│ chinook │ main    │ temp_view     │ VIEW       │ NULL        │\n├─────────┴─────────┴───────────────┴────────────┴─────────────┤\n│ 25 rows (20 shown)                                 5 columns │\n└──────────────────────────────────────────────────────────────┘\n\n\n\n\ndb.drop('cebola.*')\ndb.detach('lite_main')\n\n\ndb.tables\n\n\n\n\n\ncatalog\nschema\nname\ntype\ncomment\n\n\n\n\nchinook\nmain\nAlbum\nBASE TABLE\nAlbum table\n\n\nchinook\nmain\nArtist\nBASE TABLE\nNone\n\n\nchinook\nmain\nCustomer\nBASE TABLE\nNone\n\n\n...\n...\n...\n...\n...\n\n\nchinook\nmain\na_view\nVIEW\nJust a view\n\n\nchinook\nmain\ntemp_view\nVIEW\nNone\n\n\n\n14 rows x  5 cols      DuckDBPyRelation   \n\n\n\n\n\n\nAutocomplete in Jupyter",
    "crumbs": [
      "Source"
    ]
  }
]